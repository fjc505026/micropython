#================================================#
#  INEOS UNLOCK ALGORITHM
#  Author : Anjalysree Asokan
#================================================#

from SHA1_KEY import sha1_key
#from UDS_CFG import *
#from DATALOG import logResult
import binascii
#import pyb

#-----------------------------------------------------------------------------------------------
#       UNLOCK THE ECU
#   Unlock the ECU using key calculated using SHA-1 Algorithm
#   Return:     True    -> If the ECU unlock is successful
#               False   -> If the ECU unlock is unsuccessful
#-----------------------------------------------------------------------------------------------

# Lumen session OEM Key for INEOS (private key provided by OEM)
#OEM_key = [0x53, 0x34, 0x36, 0x37, 0x53, 0x34, 0x36, 0x37, 0x53, 0x34, 0x36, 0x37, 0x53, 0x34, 0x36, 0x37] #16 bytes
#OEM_key = [0xF1,0xFF,0x85,0xD2,0xAC,0x5F,0x27,0x2B,0xE6,0xFA,0x2F,0xED,0x3B,0xE9,0x77,0xEE] #16 bytes
OEM_key =  [0x58, 0xEE, 0x3E, 0x83, 0x9D, 0xA0, 0xC3, 0xB8, 0, 0 , 0 , 0 , 0 , 0, 0 , 0]


# def unlockECU(Diag):
#     retUnlockECU        = False
#     unpackErr           = 1

#     resExtSession       = Diag.UdsCommunication( "SessionLumen" )            # Extended Session
#     pyb.delay(50)
#     resSeedReq          = Diag.UdsCommunication( "SA_ReqSeedExt" )             # Request Seed
#     if resSeedReq != None:                                                          # Unpack 
#         try:
#             seed = resSeedReq[2:]
#             if len(seed) == 16:
#                 key = generate_key_from_seed(seed)    # calculate key from seed using sha-1 
#                 unpackErr = 0
#             else:
#                 logResult.printOnVerbose("Seed length not 16 bytes", None)
#         except (OSError, TypeError, IndexError) as err:
#             print(err)
#             logResult.printOnVerbose("Error in Unpack while Unlocking ECU", None)
            
#         if unpackErr == 0:                                                          # Create Key                
#             SA_SEND_KEY = [ 0x27,   0x62 ]
#             SA_SEND_KEY += key
            
#             logResult.printOnVerbose("SA_SendKey Request", SA_SEND_KEY)
#             udsServices[ "SA_SendKey" ]  = SA_SEND_KEY                              # Update the SEND_KEY request 
#             keyRes = Diag.UdsCommunication( "SA_SendKey" )                     # Send key request
#             if keyRes != None:                                                      # Check the response
#                 if (keyRes[0] == 0x67) and (keyRes[1] == 0x62):
#                     retUnlockECU = True
#                     logResult.printOnVerbose("ECU Unlock successful", keyRes )
#                 else:
#                     logResult.printOnVerbose("Incorrect Response Received for Unlock", keyRes )
#             else:
#                 logResult.printOnVerbose("No response received for req: SA_SendKey", None)
#     else:
#         logResult.printOnVerbose("No response received for req: SA_ReqSeedExt", None)

#     return retUnlockECU

#-------------------------------------------------------------------------------------------------#
#       Calculate Key from Seed
#   Done using HMAC SHA1 Algorithm
#   Key = H(K XOR opad, H(K XOR ipad, Seed)) 
#   Argument:   seed (random 16 byte generated by ECU)
#   return:
#       hash value of the seed (40 hexdigit)
#-------------------------------------------------------------------------------------------------#
def calculate_key_sha1(seed):

    # 1. Init K_ipad and k_opad values (B= 64 bytes)
    k_ipad = list(0x00 for i in range(64))
    k_opad = list(0x00 for i in range(64))

    # 2. Assign K value (K_ipad and k_opad values) to OEM keys
    # So here, ipad and opad will be 64 bytes (16 byte OEM key padded with 48 bytes of zeros)
    for i in range(16):
        k_ipad[i] = OEM_key[i]
        k_opad[i] = OEM_key[i]

    # 3. XOR the K_ipad with 0x36 and K_opad with0x5C for l = 64 bytes
    for i in range(0,64):
        k_ipad[i] = k_ipad[i] ^ 0x36
        k_opad[i] = k_opad[i] ^ 0x5C

    # 4. If len(k_ipad)<=64, append seed to k_ipad. ( Assumption: k = 64 bytes )
        # if len(k) > 64, we need to take the hash of 'k' and then append seed to hash value. This is not implemented here
    k_ipad = bytearray(k_ipad)
    seed = bytearray(seed)
    k_ipad += seed

    # 5. Calculate the hash value by performing SHA1 algorithm 
    h_inner = sha1_key.sha1_calculation(k_ipad)
            
    # 6. Hex string value of the k_opad 
        # Need to concatenate inner hash value to k_opad.
        # As h_inner is a hex string, make k_opad(list) to hex string too
    k_opad_hstring = ''.join('{:02x}'.format(x) for x in k_opad)
        
    # 7. Append inner hash calculated to k_opad 
    k_opad_hstring += h_inner

    # 8. Convert the hex string to byte array ( as input to sha1 function is exepected to be bytearray )
    k_opad_hstring = binascii.unhexlify(k_opad_hstring)

    # 9. Calculate hash value by performing SHA1
    h_outer = sha1_key.sha1_calculation(k_opad_hstring)

    return h_outer

#-------------------------------------------------------------------------------------------
#   Generate 16 byte key
#  Hash generated from seed would be 40 hexdigit. But we only need 32 hexdigit(16 byte) key
#  Extract the first 16 bytes of 20 byte key calculated using SHA-1
#  Convert the key from str format to array of bytes
#  return:
#       array of int (16 bytes)
#-------------------------------------------------------------------------------------------
def truncate_key( rawKeyValue ):
    truncated_32 = rawKeyValue[:32]  # Extract first 32 hexdigits
    start = 0
    end  = 2
    key_string = [0] * 16           # Init array to store key
    dec_array = []                  # Init return value

    # Hex string to array of string (16 bytes) 
    for i in range(16):
        key_string[i] = truncated_32[start:end]
        start += 2
        end += 2

    # Array of str to array of int(dec)
    # Need to send back the key to ECU as a UDS request
    for entry in key_string:
        dec_array.append(int(entry,16))
    return dec_array

#-----------------------------------------------------------------------------------------------------#
#   Generate key from random seed 
#   Hashed key from sha1 -> 40 hexdigits
#   Truncate key (extract first 32 hexdigits(16 bytes) as our ECU is only expecting 16 byte key)
#-----------------------------------------------------------------------------------------------------#
def generate_key_from_seed(seed):
    untruncated_key = calculate_key_sha1(seed)
    truncated_key = truncate_key(untruncated_key)
    return truncated_key


